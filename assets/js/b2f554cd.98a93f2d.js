"use strict";(self.webpackChunkbyconity=self.webpackChunkbyconity||[]).push([[5894],{6042:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"template","metadata":{"permalink":"/blog/template","editUrl":"https://github.com/ByConity/byconity.github.io/tree/main/blog/2024-12-11-template/index.md","source":"@site/blog/2024-12-11-template/index.md","title":"template","description":"\u786e\u8ba4\u5177\u6709\u64cd\u4f5cGitHub\u4ed3\u5e93\u6743\u9650","date":"2024-12-10T00:00:00.000Z","formattedDate":"December 10, 2024","tags":[{"label":"tag1","permalink":"/blog/tags/tag-1"},{"label":"tag2","permalink":"/blog/tags/tag-2"}],"readingTime":2.025,"hasTruncateMarker":false,"authors":[],"frontMatter":{"slug":"template","date":"2024-12-10T00:00:00.000Z","title":"template","tags":["tag1","tag2"],"keywords":["template"]},"nextItem":{"title":"Detailed Explanation of ByConity ELT Principles","permalink":"/blog/byconity-elt"}},"content":"## \u786e\u8ba4\u5177\u6709\u64cd\u4f5cGitHub\u4ed3\u5e93\u6743\u9650\\r\\n\\r\\n### \u6ce8\u518cgithub\u8d26\u53f7\\r\\n\\r\\n### \u6dfb\u52a0SSH\u5bc6\u94a5\uff08\u4e0d\u4f7f\u7528git\u53ef\u4e0d\u64cd\u4f5c\uff09\\r\\n\\r\\n```bash\\r\\nwindows + R --\x3e \u8f93\u5165powershell\\r\\n\\r\\n## powershell\u4e2d\u751f\u6210\u5bc6\u94a5\\r\\nssh-keygen -t rsa -C \\"\u4f60\u7684\u90ae\u7bb1\\"\\r\\nPS C:\\\\Users\\\\11191> ssh-keygen -t rsa -C \\"sszx24@zhejianglab.org\\"\\r\\n## \u590d\u5236\u516c\u94a5\\r\\nPS C:\\\\Users\\\\11191> cat .\\\\.ssh\\\\id_rsa.pub\\r\\nssh-rsa ...\\r\\n...\\r\\nsszx24@zhejianglab.org\\r\\n## \u6dfb\u52a0\u516c\u94a5\\r\\n\u70b9\u51fb\u5934\u50cf --\x3e Setting --\x3e SSH keys and GPG keys --\x3e New SSH key --\x3e Title --\x3e Key\uff08\u516c\u94a5\uff09 --\x3e Add SSH key \\r\\n```\\r\\n\\r\\n### \u6210\u4e3aCollaborators\\r\\n\\r\\n```bash\\r\\n\u4ed3\u5e93(lab-zhejiang.github.io) --\x3e Settings --\x3e Collaborators --\x3e Add people --\x3e \u7528\u6237\u540d\\r\\n\u5982\u8fd8\u672a\u6210\u4e3aCollaborators\u8bf7\u4e0e\u53f6\u6653\u82b3\u8054\u7cfb\\r\\n```\\r\\n\\r\\n## \u4e0a\u4f20\u6587\u4ef6\u5230github\\r\\n\\r\\n```bash\\r\\n## \u521b\u5efa\u6587\u4ef6\u5939\u547d\u540d\u4e3a \u5e74-\u6708-\u65e5-\u6587\u6863\u540d\u79f0\uff08\u9075\u5b88kebab-case\u89c4\u5219\uff09\\r\\n## \u4e0b\u8f7d\u6a21\u677f\u5230\u8be5\u6587\u4ef6\u5939\u4e2d\\r\\n\u4ed3\u5e93(lab-zhejiang.github.io) --\x3e blog --\x3e 2024-12-11-template --\x3e index.md --\x3e \u4e0b\u8f7d\\r\\n```\\r\\n![](./\u4e0b\u8f7d\u6a21\u677f\u793a\u4f8b.png)\\r\\n\\r\\n```bash\\r\\n## \u7f16\u8f91\u4e0b\u8f7d\u7684\u6587\u4ef6\\r\\n# \u4fee\u6539\u6587\u4ef6\u7684\u5143\u6570\u636e\\r\\nslug: template     # \u7528\u4e8e\u5b9a\u4e49\u9875\u9762\u7684URL\u8def\u5f84\\r\\ndate: 2024-12-10   # \u6807\u660e\u53d1\u5e03\u65f6\u95f4\\r\\ntitle: template    # \u5bfc\u822a\u4fa7\u680f\u6807\u9898\\r\\ntags: [tag1, tag2] # \u7528\u6237\u53ef\u4ee5\u70b9\u51fb\u8fd9\u4e9b\u6807\u7b7e\u6765\u6d4f\u89c8\u5176\u4ed6\u5177\u6709\u76f8\u540c\u6807\u7b7e\u7684\u6587\u7ae0\\r\\nkeywords: [\\"Test\\"] # \u5b9a\u6587\u6863\u6216\u535a\u5ba2\u6587\u7ae0\u7684\u5143\u6570\u636e\u5173\u952e\u8bcd\uff0c\u5173\u952e\u8bcd\u4e3b\u8981\u7528\u4e8eSEO\uff08\u641c\u7d22\u5f15\u64ce\u4f18\u5316\uff09\\r\\n\\r\\n# \u5220\u9664\u5206\u5272\u7ebf\u4e0b\u65b9\u5185\u5bb9\u5e76\u6539\u4e3a\u6240\u8981\u4e0a\u4f20\u7684\u6587\u6863\u5185\u5bb9\\r\\n\\r\\n# \u4e0a\u4f20\u76f8\u5173\u56fe\u7247\u81f3\u6587\u4ef6\u5939\u4e2d\uff0c\u5e76\u4fee\u6539\u6587\u6863\u4e2d\u56fe\u7247\u7684\u8def\u5f84\u4e3a./\u56fe\u7247\u540d\u79f0\\r\\n\\r\\n## \u4e0a\u4f20\u6587\u4ef6\u5939\\r\\n\u4ed3\u5e93(lab-zhejiang.github.io) --\x3e blog --\x3e Add file --\x3e Upload files --\x3e Create a new branch for this commit and start a pull request. --\x3e Propose changes\\r\\n```\\r\\n\\r\\n![](./\u4e0a\u4f20\u6587\u4ef6\u793a\u4f8b.png)\\r\\n\\r\\n## \u901a\u77e5\u7ba1\u7406\u5458\u5ba1\u6279\u4e0a\u4f20\u6587\u4ef6\u7684\u8bf7\u6c42"},{"id":"byconity-elt","metadata":{"permalink":"/blog/byconity-elt","editUrl":"https://github.com/ByConity/byconity.github.io/tree/main/blog/2023-09-10-byconity-elt/index.md","source":"@site/blog/2023-09-10-byconity-elt/index.md","title":"Detailed Explanation of ByConity ELT Principles","description":"Background","date":"2023-09-10T00:00:00.000Z","formattedDate":"September 10, 2023","tags":[{"label":"video introduction","permalink":"/blog/tags/video-introduction"},{"label":"docusaurus","permalink":"/blog/tags/docusaurus"}],"readingTime":9.71,"hasTruncateMarker":false,"authors":[{"name":"Tao Wang","title":"ByConity maintainer","url":"https://github.com/WangTaoTheTonic","imageURL":"https://github.com/WangTaoTheTonic.png","key":"WangTaoTheTonic"},{"name":"Yunbo Wang","title":"ByConity maintainer","url":"https://github.com/tigerwangyb","imageURL":"https://github.com/tigerwangyb.png","key":"tigerwangyb"}],"frontMatter":{"slug":"byconity-elt","title":"Detailed Explanation of ByConity ELT Principles","authors":["WangTaoTheTonic","tigerwangyb"],"tags":["video introduction","docusaurus"]},"prevItem":{"title":"template","permalink":"/blog/template"}},"content":"## Background\\n\\nWhen it comes to data warehouses, the use of Extract-Transform-Load (ETL) or Extract-Load-Transform (ELT) is inevitable. It involves extracting data from different sources and in various formats into a data warehouse for processing. Traditionally, the data transformation process uses Extract-Transform-Load (ETL) to convert business data into a data model suitable for data warehouses. However, this relies on an ETL system independent of the data warehouse, resulting in high maintenance costs. As a cloud-native data warehouse, ByConity has gradually supported Extract-Load-Transform (ELT) since version 0.2.0, freeing users from maintaining multiple heterogeneous data systems. This article will introduce ByConity\'s capabilities, implementation principles, and usage methods related to ELT.\\n\\n## ETL Scenarios and Solutions\\n\\n### Differences between ELT and ETL\\n\\n- ETL: Describes the process of extracting data from a source, transforming it, and loading it into a destination (data warehouse). The Transform phase typically describes the preprocessing of data within the data warehouse.\\n\\n![](./elt1.png)\\n\\n- ELT focuses on loading minimally processed data into the data warehouse, leaving most of the transformation operations to the analysis phase. Compared to ETL, it requires less data modeling and provides analysts with more flexibility. ELT has become the norm in big data processing today, posing many new requirements for data warehouses.\\n\\n### Challenges of Resource Duplication\\n\\n![](./elt2.png)\\n\\nA typical data pipeline is as follows: We ingest behavioral data, logs, clickstreams, etc., into a storage system using MQ/Kafka/Flink. The storage system can be further divided into on-premises HDFS and cloud-based OSS&S3 remote storage systems. Then, a series of ETL operations are performed on the data warehouse to provide data for OLAP systems for analysis and query. However, some businesses need to branch off from the above storage, exporting data from the overall pipeline at a certain stage of data analysis to perform ETL operations different from the main pipeline, resulting in duplicate data storage. Additionally, two different ETL logics may emerge during this process.\\n\\nAs the amount of data increases, the cost pressure brought by computational and storage redundancy also increases. Meanwhile, the expansion of storage space makes elastic scaling inconvenient.\\n\\n### Industry Solutions\\n\\nIn the industry, there are several approaches to address the above issues:\\n- Data pre-calculation school: Tools like Kylin. If report generation in Hadoop systems is slow or aggregation capabilities are poor, data pre-calculation can be performed to calculate cubes or views in advance for configured indicators. During actual SQL queries, the cubes or views can be directly used for substitution and returned.\\n- Streaming and batch integration school: Tools like Flink, Risingwave. Data is aggregated directly in memory for reports or large screens as it flows in. After aggregation, the results are written to HBase or MySQL for retrieval and display. Flink also exposes interfaces for intermediate states, i.e., queryable state, to enable users to better utilize state data. However, the final results still need to be reconciled with batch computation results, and if inconsistencies are found, backtracking operations may be required. The entire process tests the skills of operation and maintenance/development teams.\\n- Data lake and warehouse integration & HxxP: Combining data lakes with data warehouses.\\n\\n## ELT in ByConity\\n\\n### Overall Execution Flow\\n\\n![](./elt3.png)\\n\\n### System Requirements for ELT Tasks:\\n\\n1. Overall scalability: Importing and transforming often require significant resources, and the system needs to scale horizontally to meet rapid data growth.\\n2. Reliability and fault tolerance: Large numbers of jobs can be scheduled orderly; in case of occasional task failures (OOM), container failures, etc., retries can be triggered; able to handle a certain degree of data skewness.\\n3. Efficiency and performance: Effective utilization of multi-core and multi-machine concurrency; fast data import; efficient memory usage (memory management); CPU optimization (vectorization, codegen).\\n4. Ecosystem and observability: Compatible with various tools; task status awareness; task progress awareness; failed log query; certain visualization capabilities.\\n\\nBased on the requirements of ELT tasks and the difficulties encountered in current scenarios, ByConity has added the following features and optimizations.\\n\\n### Stage-level Scheduling\\n![](./elt4.png)\\n\\n#### Principle Analysis\\n- The current SQL execution process in ClickHouse is as follows:\\n  - In the first stage, the Coordinator receives a distributed table query and converts it into a local table query for each shard node.\\n  - In the second stage, the Coordinator aggregates the results from each node and returns them to the client.\\n- ClickHouse converts the right table in Join operations into a subquery, which brings several issues that are difficult to resolve:\\n  - Complex queries have multiple subqueries, resulting in high conversion complexity.\\n  - When the Join table is large, it can easily cause OOM in worker nodes.\\n  - Aggregation occurs at the Coordinator, putting pressure on it and easily becoming a performance bottleneck.\\n\\n![](./elt5.png) ![](./elt6.png) ![](./elt7.png)\\n\\nUnlike ClickHouse, we have implemented optimization for the execution of complex queries in ByConity. By splitting the execution plan, we transform the previous two-stage execution model into stage-level execution. During the logical plan phase, exchange operators are inserted based on operator types. During the execution phase, the entire execution plan is DAG-split based on exchange operators, and scheduling is performed stage by stage. The exchange operators between stages are responsible for data transmission and exchange.\\nKey nodes:\\n1. Insertion of exchange nodes\\n2. Splitting of stages\\n3. Stage scheduler\\n4. Segment executer\\n5. Exchange manager\\n\\n![](./elt8.png)\\n\\nHere, we focus on the exchange perspective. As you can see in the figure above, at the top level is the query plan. When converting it to a physical plan, we transform it into different operators based on different data distribution requirements. The source layer, which receives data, is mostly unified and called ExchangeSource. Sinks have different implementations, such as BroadcastSink, Local, PartitionSink, etc., which run as part of map tasks. For cross-node data operations, we use a unified brpc streaming data transmission at the bottom level, and for local operations, we use memory queues. We have made very detailed optimizations for different points:\\n- Data transmission layer\\n  - In-process communication uses memory queues, without serialization, zero copy\\n  - Inter-process communication uses brpc stream RPC, ensuring order preservation, connection reuse, status code transmission, compression, etc.\\n- Operator layer\\n  - Batch sending\\n  - Thread reuse, reducing the number of threads\\n\\n#### Benefits\\n\\nBecause ByConity fully adopts a multi-stage query execution approach, there are significant overall benefits:\\n- More stable and efficient Coordinator\\n  - Aggregation and other operators are split to worker nodes for execution\\n  - The Coordinator node only needs to aggregate the final results\\n- Reduced Worker OOM\\n  - Stage splitting makes each stage\'s computation relatively simple\\n  - The addition of exchange operators reduces memory pressure\\n- More stable and efficient network connections\\n  - Effective transmission by exchange operators\\n  - Reuse of connection pools\\n\\n### Adaptive Scheduler\\n\\nThe Adaptive Scheduler is a feature we have implemented for stability. In OLAP scenarios, it may be found that some data is incomplete or data queries timeout, often due to the fact that each worker is shared by all queries. Once a worker is slow, it can affect the execution of the entire query.\\n\\n![](./elt9.png)\\n\\nIssues with shared computation nodes:\\n- The load on the node where Scan occurs is related to the amount of scan data required by different queries, and it cannot be perfectly averaged.\\n- The resource requirements vary greatly among Plan Segments.\\nThis leads to severe load imbalance among worker nodes. Heavily loaded worker nodes can affect the overall progress of the query. Therefore, we have implemented the following optimization solutions:\\n- Establishment of a Worker health mechanism. The server side establishes a Worker health management class that can quickly obtain health information about the Worker Group, including CPU, memory, the number of running queries, etc.\\n- Adaptive scheduling: Each SQL dynamically selects and controls the concurrency of computation nodes based on Worker health.\\n\\n### Query Queue Mechanism\\n\\n![](./elt10.png) ![](./elt11.png)\\n\\nOur clusters may also experience full load situations, where all workers are unhealthy or overloaded/overloaded. In such cases, we use a query queue for optimization.\\nWe directly implemented a manager on the server side. Each time a query is made, the manager checks the cluster\'s resources and holds a lock. If resources are insufficient, it waits for resources to be released before waking up the lock. This avoids the server issuing unbounded computation tasks, leading to worker node overloads and crashes.\\nThe current implementation is relatively simple. The server is multi-instanced, and each server instance has its own queue, providing a local perspective lacking a global resource perspective. Additionally, the query status in each queue is not persisted but simply cached in memory.\\nIn the future, we will add coordination between servers to limit query concurrency from a global perspective. We will also persist\\n\\n### Async Execution\\n\\n![](./elt12.png)\\n\\nA typical characteristic of ELT tasks is that their running time is relatively long compared to real-time analysis. Generally, ELT tasks can take minutes or even hours to execute.\\nCurrently, ClickHouse\'s client queries are returned in a blocking manner. This results in the client remaining in a waiting state for an extended period, during which it needs to maintain a connection with the server. In unstable network conditions, the connection between the client and server may be disconnected, leading to task failures on the server side.\\nTo reduce such unnecessary failures and reduce the complexity of maintaining connections for the client, we have developed an asynchronous execution feature, which is implemented as follows:\\n\\n1. User-specified asynchronous execution. Users can specify asynchronous execution on a per-query basis by using `settings enable_async_query = 1`. Alternatively, they can set it at the session level using `set enable_async_query = 1`.\\n2. If the query is asynchronous, it is placed in a background thread pool for execution.\\n3. Silent I/O. When an asynchronous query is executing, its interaction with the client, such as log output, needs to be severed.\\n\\nInitialization of the query still occurs in the session\'s synchronous thread. Once initialization is complete, the query state is written to the metastore, and an async query ID is returned to the client. The client can use this ID to query the status of the query. After the async query ID is returned, it indicates the completion of the interaction for this query. In this mode, if the statement is a `SELECT`, subsequent results cannot be sent back to the client. In such cases, we recommend users use a combination of async query and `SELECT...INTO OUTFILE` to meet their needs.\\n\\n## Future Plans\\n\\nRegarding ELT mixed loads, the ByConity 0.2.0 version is just the beginning. In subsequent versions, we will continue to optimize query-related capabilities, with ELT as the core focus. The plans are as follows:\\n\\n### Fault Recovery Capabilities\\n\\n- Operator Spill\\n  - Spill for Sort, Agg, and Join operators;\\n  - Exchange Spill capability;\\n- Recoverability\\n  - Operator execution recovery: When ELT tasks run for a long time, occasional failures of intermediate tasks can lead to the failure of the entire query. Supporting task-level retries can significantly reduce occasional failures caused by environmental factors;\\n  - Stage retries: When a node fails, stage-level retries can be performed;\\n  - Ability to save queue job states;\\n- Remote Shuffle Service: Currently, open-source shuffle services in the industry are often tailored for Spark and lack generic clients, such as C++ clients. We will supplement this capability in the future.\\n\\n### Resources\\n\\n- Specifiable computational resources: Users can specify the computational resources required for a query;\\n- Computational resource estimation/reservation: Dynamically estimate the computational resources required for a query and allocate them through reservation;\\n- Dynamic resource allocation: Currently, workers are permanent processes/nodes. Dynamic resource allocation can improve utilization;\\n- Fine-grained resource isolation: Reduce the mutual influence between queries through worker group or process-level isolation;"}]}')}}]);